\section{\sys API}
\label{s:api}

\begin{figure}[t]
\begin{lstlisting}[style=rust,escapeinside={(*}{*)}]
// Generates keypair for p and returns the user's backup credential
(*\textbf{RegisterPrincipal}*)(
        p: UID, 
        pw: Password,
        pubkey: PublicKey, 
        privkey: PrivKey)
    -> RevealCredential;

// disguises principal p according to the spec, 
// optionally over already-disguised data ((*\S\ref{s:composition}*))
(*\textbf{DisguiseData}*)(
        p: Option<UID>, 
        spec: DisguiseSpec,
        principal_gen: PrincipalGenerator,
        schema: Schema,
        disguise_over: Option<RevealCredential>) 
    -> disguiseID;

// Reveals data disguised by s for p with p's password. 
(*\textbf{RevealData}*)(
        p: Option<UID>, 
        did: disguiseID, 
        pp_ref_policy: PseudoprincipalReferencePolicy,
        allow_partial_row_reveal: bool,
        schema: Schema,
        cred: RevealCredential>)
    -> bool;

// Gets principals that p can speak-for.
(*\textbf{CanSpeakFor}*)(p: UID, cred: RevealCredential) -> Vec<UID>;

// Records a reveal-time update spec in the replay log.
(*\textbf{RecordUpdate}*)(update_spec: RevealTimeUpdateSpec) -> bool;
\end{lstlisting}
\caption{\sys's API (Rust-like syntax).}
\label{f:api-high}
\end{figure}
%

Developers add hooks to their application to invoke \sys's API, which consists
of the following functions (Figure~\ref{f:api-high}). This section describes
each function and how developers would use them to support disguising and
revealing.

\subsection{\texttt{RegisterPrincipal}}

    Registers an application user as a principal whose data can be disguised and
    revealed. Unique users should not be registered multiple times.  Once
    registered, data of an undeleted user that exists in the database can always
    be disguised and revealed.

    \paragraph{Arguments.} Takes the user's associated unique identifier and unique
    public-private keypair (generated by the user
    client or application).
    %
    The provided public key is used to encrypt the user's disguised data. The
    provided private key and password enable clients to later reveal data using
    either the private key or password.

    \paragraph{Return Value.} 
    The function returns a backup token that the application should return to
    the user client. This token enables the user to reveal in the case they lose
    their password or private key.


\subsection{\texttt{DisguiseData}}
    \todo{principals vs users?}

    Rewrites and/or removes data from the application database according to the
    provided disguise specification (\ie disguises data). The original data is encrypted
    and stored within the application database; a user must provide credentials
    to invoke with a \texttt{RevealData} call in order to restore the data.
    
    This function may insert pseudoprincipals (anonymous users) into the
    application database if a decorrelation---a rewriting of a foreign key to
    point to an anonymous principal instead of an 
    original principal user---is specified by the disguise.
    \todo{we haven't talked about decorrelation yet?} Data disguised within the
    same disguise may refer to (via a foreign key) the same pseudoprincipal
    specified.
    %
    No two disguises' sets of produced pseudoprincipals overlap. 

    \paragraph{Arguments.} 
    A disguise is invoked either automatically by the application, or a specific
    user of the application identified by user ID. 
    % 
    If disguise is user-specific, then only data that has a foreign key to that
    user's identifier (is ``owned'' by that user), and which matches the
    disguise specification, will be disguised.  Otherwise, all data matching the
    disguise specification will be disguised (potentially owned by multiple
    users). 
    %

    %
    If a user invokes a disguise through the application and provides a reveal
    credential (their password, private key, or backup token), the function will
    disguise data that has already been disguised (\S\ref{s:composition}).
    Depending on the disguise specification, this will remove, modify, or create
    a new pseudoprincipal owner for data with a foreign key to a pseudoprincipal
    instead of the user.
    %

    %
    The developer provides three arguments:
    \begin{itemize}[nosep]
    \item A disguise specification that describes how to disguise data by
    removing, modifying (replacing some or all of its contents with placeholder
    values), or decorrelating, replacing links to users with links to
    pseudoprincipals.
    
    \item A principal generator, which describes how to create a
    pseudoprincipal in the application (global across all disguises).
    
    \item The database schema, which specifies ownership links from data tables to user
    tables via foreign key relationships (global across all disguises).
    \end{itemize}

    \paragraph{Return Value.} 
    The function returns a unique disguise ID for the applied disguise, which
    should be returned to affected users in case they wish to later reveal the
    disguise.

    \paragraph{Special Considerations.}
    \todo{clarify.}
    If a data row to be removed by the disguise is shared among multiple users,
    the data row is only removed once all users have agreed to disguise. This
    occurs if \one{} all users individually disguise the data (\texttt{p =
    Some(uid)} for all owners \texttt{p}), or \two{} the disguise is applied
    over all users (\texttt{p = None}).
   
    If the data is not removed (some owning users have not disguised the row),
    the data will refer to a pseudoprincipal for users who have disguised.


\subsection{\texttt{RevealData}}
    Restores data disguised by the disguise corresponding to the provided ID to
    the database. Revealing the same disguise ID multiple times will do nothing
    after the first reveal.

    If revealing a row violates database constraints specified in the schema
    (\eg uniqueness, referential integrity, NULl checks), \texttt{RevealData}
    will not restore that row.  \texttt{RevealData} may fail to restore some
    rows, but will still reveal others that successfully pass all constraints
    checks.

    Revealing a row operates on a per-attribute granularity. If an attribute of
    a row at the time of reveal differs from the attribute value set when
    \texttt{DisguiseData} disguised the row, then that attribute of the row will
    not be restored to the original value. This prevents \texttt{RevealData}
    from overwriting an application change since the time of disguise. 
    %
    \texttt{RevealData} will still reveal matching attributes for the row unless
    developers diable partial row removal
    (\texttt{allow\_partial\_row\_reveal}).

    Revealed data will reflect all of the updates registered via
    \texttt{RecordUpdate} since the time of disguise \texttt{did}, applied in
    chronological order.

    \paragraph{Arguments.} 
    A reveal is invoked by a specific
    user of the application identified by user ID. 
    % 
    The user also provides a reveal
    credential (their password, private key, or backup token) and the 
    identifier for the disguise to reveal.

    The developer provides three arguments:
    \begin{itemize}[nosep]
    \item A pseudoprincipal reference policy (\texttt{RECORRELATE}, \texttt{REMOVE},
    or \texttt{RETAIN}) to ensure that reveals of decorrelations preserve
    referential integrity. \texttt{RECORRELATE} ensures that any table rows that
    have been added since the time of disguise, and which have foreign
    key references to a pseudoprincipal row that is removed by the reveal, will
    reference the revealed user replacing the pseudoprincipal.
    \texttt{REMOVE} removes such new references to removed pseudoprincipal rows,
    and \texttt{RETAIN} prevents \texttt{RevealData} from the removing
    pseudoprincipal row and retains any new references to it.
     
    \item A flag specifying whether a row can be partially restored if some
    attributes at the time of reveal differ from the attribute values set when
    disguising the row.

    \item The database schema, which specifies ownership links from data tables to user
    tables via foreign key relationships (global across all disguises).
    \end{itemize}

    \paragraph{Return Value.} 
    Returns true if all rows to reveal pass database constraint checks, and false otherwise.

    \paragraph{Special Considerations.}
    \todo{shared data, composition}

\subsection{\texttt{CanSpeakFor}}
    Finds all principals in the application identified by user ID that stem from
    a (potentially recursive) decorrelaton of user \texttt{p}.
    User \texttt{p} is thus authorized to speak-for any of these principals.

    \paragraph{Arguments.} 
    \texttt{CanSpeakFor} is invoked on behalf of some user with UID \texttt{p},
    and with the user's password.

    \paragraph{Return Value.} 
    A list of all user IDs of principals that \texttt{p} can
    speak-for.

\subsection{\texttt{RecordUpdate}}
Enables a developer to perform updates to disguised data prior to revealing it.
Invoking \texttt{RecordUpdate} timestamps and logs a developer-provided update
specification---a data transformation function---to reflect a global update
performed on undisguised data. All updates since the time of disguise will be
performed in chronological order on disguised data prior to revealing it.

If the provided reveal-time update specification relies on data external to the
disguised data to reveal (\eg the current time or state of undisguised data),
\sys cannot ensure correctness when applying the update to disguised data at
revveal time.

    \paragraph{Arguments.} Takes a reveal-time update specification reflecting
    the data transformations performed on table rows. The specification maps a
    set of table rows to a set of updated table rows.

    \paragraph{Return Value.} Returns true on successful recording in \sys's
    log, and false on failure.

\subsection{Example API Usage}

\todo{Examples of applying the API and resulting DB state with pseudoprincipals?
Lobsters example? Shared data, composition, reveal-time updates?
Hard to catch every edge condition...}


\iffalse
%
(1) An application registers users with a public--private keypair
that either the application or the user's client generates; \sys stores the
public key in its database, while the user retains the private key for use in
future reveal operations.
%

%
(2) When the application wants to \xx some data, it invokes \sys with the
corresponding developer-provided \xx specification and any necessary
parameters (such as a user ID).
%
\Xx specifications can remove data, modify data (replacing some or all of its
contents with placeholder values), or decorrelate data, replacing
links to users with links to pseudoprincipals (fake users).
%
% Decorrelation preserves the structure of the application database, and avoids
% integrity issues like dangling foreign keys, while obscuring the data's
% relationship to natural principals (true users).
%
\sys takes the data it removed or replaced and the connections between
the user and any pseudoprincipals it created, encrypts that data with the user's
public key, and stores the resulting ciphertext---the \emph{\xxed
data}---such that it cannot be linked back to the user without the user's
private key.
%
%The application's database now no longer contains the \xxed data.
%


%
(4) When a user wishes to reveal their \xxed data, they pass credentials
to the application, which calls into \sys to reveal the data.
%
Credentials are application-specific: users may either provide their private
key or other credentials sufficient for \sys to re-derive the private key.
%
\sys reads the \xxed data and decrypts it, undoing the changes to the
application database that \xxing introduced.
%

%
\sys provides the developer with sensible default \xxing and revealing
semantics (\eg revealing makes sure not to overwrite changes made since
\xxing).
\fi
