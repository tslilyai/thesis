This chapter describes the design of \sys and the techniques \sys uses to
support disguising and revealing. We first look at how \sys performs disguising
transformations, and then dive into the details of how \sys reveals disguised
data.
We then describe the more complicated scenarios possible with \sys, namely
disguise composition, shared data, and action as pseudoprincipals.  This chapter
concludes with an analysis of the security of \sys's design with respect to the
threat model described in \S\ref{s:threat}.

\section{\Xxing}
\label{s:applying}

To apply a \xxing transformation, \sys creates a unique \emph{\xx ID} and
queries for the data to \xx based on the \xx specification predicates.
%\lyt{Selecting all
%predicated data prior to performing database modifications ensures that
%any updates during \xxing do not affect what data to \xx. (put as footnote?
%cut? dunno)}
%
To preserve referential integrity, \sys constructs a dependency graph between
tables based on foreign key relations (assuming no circularity), and first
performs removes from tables in topologically-sorted order.  \sys then performs
decorrelations and modifications in specification order, potentially generating
and storing pseudoprincipals.
%

%If \sys must apply more than one change to the same selected data object
%attribute (\eg because the object satisfies multiple predicates), \sys applies
%the changes in the order specified in the spec.
%
%The developer can reason about which objects are \xxed based on the state of
%the database at the point of time the \xxing transformation occurs.
%

%
Next, to record disguised data, \sys generates \emph{diff records} that contain \one{}
the original data row(s), and \two{} placeholder data rows the disguise inserted
or rewote in the application (\eg pseudoprincipals or the value of any modified
columns).
%
All types of diff records also contain the \xx ID. 
%
The original and placeholder rows contained by a diff record varies by disguise
operation as follows:
\begin{itemize}[nosep]
    \item Remove diff records contain \one{} the removed original row, and \two{} no
        placeholder rows;
    \item Modify diff records contain \one{} the unmodified row, and \two{} the
        row with the modified value; and
    \item Decorrelate diff records contain \one{} the referencing row with the original
        foreign key value, and \two{} the referencing row with the placeholder
        foreign key value pointing to a pseudoprincipal, and the pseudoprincipal's row.
\end{itemize}
%
For each new pseudoprincipal, \sys generates a public--private keypair and adds
a \emph{speaks-for record}, which adds a link to the original principal's
\emph{speaks-for chain}.
A speaks-for record contains a pair of (original principal,
pseudoprincipal) IDs and the pseudoprincipal’s
private key. \sys registers the pseudoprincipal with its public key to enable
composition of disguises (\S\ref{s:composition}).
%
\sys then encrypts the diff and speaks-for records with the principal's key,
and stores them in the database.
%
%
%
Finally, \sys returns the \xx ID to the application.
%
A client can use the \xx ID and the principal's
credentials to reveal the transformation later.
%

\begin{figure}[!t]
\centering
\includegraphics{figs/lobsters_catanon_visual}
\caption{When \sys applies topic-based anonymization to Bea's comments on
    stories tagged ``Star Wars'' (red), these comments are decorrelated to
    pseudoprincipals (``AnonPig'', ``AnonFox''). \sys stores encrypted
    speaks-for records mapping Bea to their
    pseudoprincipals, and diff records containing the comments with
    modified foreign keys.}
\label{f:lobsters_visual}
\end{figure}


%
To perform Bea's topic-based anonymization (Figure~\ref{f:lobsters_visual}),
\sys thus:
%
\one{} queries the database to fetch comments and votes by Bea
affiliated with ``Star Wars'';
%
\two{} creates a pseudoprincipal (\eg
``AnonFox'') for every ``Star Wars''-tagged story that Bea commented
on, and inserts it as a new user;
% into the database;
%
\three{} modifies the database by rewriting comment
foreign keys to point to the created pseudoprincipals, and
removing Bea's votes on those stories;
%
\four{} creates new speaks-for records that map Bea to the created
pseudoprincipals and create new links in Bea's speaks-for chain; diff records
containing Bea's votes on ``Star Wars'' stories; and diff records that document
Bea's original ownership of ``Star Wars''-tagged comments and the placeholder
pseudoprincipal data;
%
\five{} encrypts the speaks-for and diff records with Bea's public key, stores
them; and
%
\six{} returns a unique \xx ID to the application.

%
% \sys's security properties require that \xx records be untraceable: even a
% complete dump of \sys's state should not allow an attacker to match \xx records
% with users.
% %
% But efficient revealing requires there be a way to reference the records for a
% given \xx transformation and principal.
% %
% To this end, \sys encrypts both \xx records \emph{and} references to \xx
% records using principal public keys, which we describe next.
%
%We now describe how this works.
%

\sys adds a \emph{\xx table} and a \emph{principal table} to the application
database to store principals' \xxed data.
%
The \xx table contains lists of per-principal diff and speaks-for records encrypted with the
principal's public key.
%(Recall that private keys are not stored in the database.)
%; for instance, \verb+\xx_table[1]+ might be a list of \xx records
%pertaining to Bea's \xxing of ``Star Wars'' comments.
%
%These records are encrypted
%by Bea's public key, and thus can only be decrypted when Bea's private key is
%available.
%
The principal table is indexed by application user ID; each row contains the
principal's public key, and a list of \xx table indexes encrypted with the
public key.
%
To store records for principal $p$, \sys \one{} encrypts the records with
$p$'s public key; \two{} stores the ciphertext in the \xx table under index
\fn{idx}; \three{} encrypts \fn{idx} (salted to
prevent rainbow table attacks) with $p$'s public key; and \four{} appends the
encrypted \fn{idx} to $p$'s list of encrypted \xx tables indexes
in the principal table.
%an encrypted $[i \parallel \text{random-nonce}]$ (encrypted with the principal's public key).
%encrypts $[i \parallel \text{random-nonce}]$ with the principal's public
%key and appends the result to its principal table record.

%
This allows \sys to store records without needing access to the principal's
private key, and to do so securely: the principal table adds a layer of
indirection from user ID to encrypted records, so an attacker cannot link
principals to their records.
%
At reveal time, \sys can efficiently find \xxed data for a given user
by decrypting and using \xx table indexes in the principal table.
%
%This also hides from an attacker which \xxed data belongs to a given principal
%because entries in the principal table cannot be interpreted without
%principals' private keys, which are not stored in the database.
%

%
\Xxing transformations may completely remove a principal from the
application database.
%
When this happens, \sys moves the corresponding list of encrypted \xx table
indexes from the principal table to a \emph{deleted principal table} indexed
opaquely, \eg by the public key.
%
This removes the user ID from the database while allowing future reveal
operations by the principal to find their \xx table indexes.
%
\sys also stores a special type of remove diff record that contains the
principal's ID and the principal's public key when a disguise removes a principal.  This
allows \sys to restore the principal to \sys's principal table if a user later
reveals the disguise.
%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Revealing}
\label{s:reveal}

%
To apply a reveal transformation, \sys first locates and decrypts the
corresponding diff and speaks-for records using a \xx ID and the user’s reveal
credentials.
%

\begin{figure}[t]
  \small
\begin{lstlisting}[style=pseudo,escapeinside={(*}{*)}]
Reveal(disgID, uid, privkey):
 encrypted_disg_table_idxs := principal_table[uid]
 decrypted_disg_table_idxs :=
    decrypt(encrypted_disg_table_idxs, privkey)
 for idx in decrypted_disg_table_idxs:
   records = decrypt(disg_table[idx], privkey)
   for rec in records:
     if rec.disgID == disgID:
       // apply rec to application database
       // remove rec from disg_table
     else if rec.type == SPEAKS_FOR:
       // recursively reveal for pseudoprincipal
       // generated by another disguise
       Reveal(disgID, rec.pp_uid, rec.pp_privkey)
\end{lstlisting}
    \caption{Pseudocode for revealing a \xxing transformation while
    application principal \fn{uid} exists. Recursive revealing (the
    \texttt{\small else} clause) walks the speaks-for chain to reveal composed
    records of pseudoprincipals created by other disguising transformations
    if necessary (\S\ref{s:composition}).}
  \label{f:revealpseudo}
\end{figure}

\sys's reveal procedure (Figure~\ref{f:revealpseudo}) first looks up all \xx
records related to the provided reveal credentials via \sys's principal and \xx
tables.
%
\sys then applies diff records created for the \verb+disgID+ \xx transformation
to the database, thus restoring the relevant
application objects to their pre-\xxed state.
% Additionally, \sys recursively applies the procedure for
% pseudoprincipals that the current user speaks-for; this supports the
% composition of \xxing transformations, such as a Lobsters user who removes
% their previously-anonymized contributions (\S\ref{s:composition}).

%
To preserve referential integrity, \sys restores
\xxed data that was removed from tables in topologically-sorted order (again
constructing the dependency graph).
%
\sys then reveals any modifications, and finally performs recorrelations. 
%
In general, to reveal a diff record, \sys removes the placeholder row
and inserts the original row (both of which are recorded in the diff record).
%
However, for efficiency, \sys first checks if a placeholder row in diff records
has the same identifiers (\eg a primary key) as an original data row in the diff
record, and if so, will update the relevant columns of the placeholder row instead.
%

%
Finally, \sys de-registers any pseudoprincipal who no longer has any associated
disguised data, removing them from the principal table and the application's
users table.
%
Developers can configure \sys to also check for references to pseudoprincipals
prior to removing them, and depending on the application's needs, configure \sys
to delete, rewrite, or leave the references in place.
%
After revealing, the \xxed data is no longer needed, so \sys clears the
corresponding diff and speaks-for records.
%

%
In the example, if Bea wants to reveal their ``Star Wars'' contributions,
Lobsters invokes \sys with the \xx ID and Bea's password as reveal credentials.
%to reveal their Star Wars \xxing transformation.
%
\sys uses the password to reconstruct Bea's private key, retrieve and decrypt
Bea's records, and filter those records for those with the \xx ID.
%
\sys then restores deleted votes and Bea's ownership of
decorrelated comments.
%

\section{Database Management Operations}

\sys's revealing as described thus far may accidentally reveal data that ignores
database management operations applied since the time of disguise, such as
global application updates to un\xxed data or schema migrations.
%
To prevent this, \sys utilizes developer-provided information about important
updates and schema migrations to apply them to \xxed data prior to revealing it,
ensuring that revealed data reflects the current state of the database.
%
Prior to revealing the updated data, \sys will also perform consistency checks
to guarantee adherence to internal database invariants, such as uniqueness
constraints.
%
Here, we describe how developers specify application updates and schema
migrations; how \sys applies these updates to data to reveal; and \sys's
consistency checks.

%
\subsection{Application Updates.}

\begin{figure}
    \centering
    \includegraphics[width=.8\textwidth]{figs/update-moderation}
    \caption{When the application applies updates like moderations of explicit
    words, it can invoke \sys to log the update. \sys then applies the
    update to disguised data in diff records prior to reveal. Yellow 
    highlights changes to the application data or \sys's data.}
\label{f:update:mod}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[width=.8\textwidth]{figs/update-migration}
  \caption{Similar to a moderations update, the application can notify \sys of a
    schema migration to apply to diff records prior to reveal. Yellow 
    highlights changes to the application data or \sys's data. For simplicity,
    only the placeholder data of a pseudoprincipal row is shown; in reality,
    placeholder data exists as part of \eg a decorrelation diff record.}
\label{f:update:schema}
\end{figure}

In order for revealing to preserve application correctness, \sys must know about
application updates that alter invariants over application data.
%
Consider an example where a moderator periodically edits all posts to remove
swear words, creating an implicit invariant that all posts created prior to the
last moderation pass should contain no swear words.
%
If a user's disguise removes their posts, then a moderation pass occurs, and
then the user wants to restore their posts, \sys would not know about these
moderation updates to posts of the application and incorrectly restore the
original post content with swear words present upon reveal.
%
However, \sys could correctly restore the post if it knew to remove the swear
words prior to reveal.
%
%Likewise, if \sys removed the post instead of scrubbing its content, the
%moderator would never see it (and could not edit it), but \sys would reveal the
%post with swear words still present.
%
%In the first scenario, \sys knows that an update was applied, and refuses to
%reveal the modified post; in the second, \sys does \emph{not} know that
%moderation happened and reveals the removed post.
%%
%Neither might be what the application desires.
%

\sys handles this situation by tracking applied application updates in a
\emph{replay log} of application update specifications.
%
Figure~\ref{f:update:mod} demonstrates how \sys applies application updates to
disguised data.
\begin{enumerate}[nosep]
    \item[(1)] \sys disguises some user data.
    \item[(2)] The application invokes \sys when it
performs operations that need to hold over disguised data when it is
revealed---\eg moderations---and \sys records these updates in its replay log.
    \item[(3)] When revealing data, \sys applies, in order, every entry in the replay log
added since the time of disguise to the disguise's diff records.
Updates map the original data and the placeholder data in diff records
to corresponding updated-original and updated-placeholder data. 
\item[(4)] After applying all updates to placeholder data, \sys reveals the updated rows in
the diff record like normal.
\end{enumerate}
%
%Similarly, after applying all updates to the original data, \sys takes the
%updated-original data and restores it to the database.
%%
%As before for efficiency, \sys will first check if an updated-placeholder row has
%the same identifiers as an updated-original data row, and if so, will update the
%relevant columns of the placeholder row instead.
%
%
In the swear words moderation example, \sys queries the replay log, sees
the swear words moderation entry, and then applies the swear words moderation to
the removed post data in the diff record. Only then does \sys restore the post
with no swear words.\footnote{Note that in this example, the diff
record contains no placeholder data that replaced the removed post; in other
scenarios such as decorrelation or modification, \sys would apply the logged
update to placeholder data as well. The updated placeholder data would then be
removed.}

\subsection{Schema Migrations}
%
Applications also constantly undergo database management operations which
migrate its schema to reorganize data or add new application features. When
these occur, \sys must know how to manipulate any disguised data structured in
the old database layout to match that of the current database.
%
At first glance, global application updates like URL normalization might seem
like a different class of database management operation than structural changes
like schema migration, and require a different approach.
%
However, the technique just described for application updates allows \sys to
handle schema migrations as well. 
%

%
Take, for example, a developer of an application with a \texttt{users} table
that contains rows with \texttt{username}s, \texttt{addr}s, and \texttt{email}s.
The developer may choose to allow users multiple addresses via a schema
migration. To do so, they would create a new \texttt{addrs} table, with a
foreign key to the users table, and populate \texttt{addrs} using the address
data in \texttt{users}.  Finally, they would remove the \texttt{addr} column
from \texttt{users}.
%

Figure~\ref{f:update:mod} demonstrates how \sys applies such a schema migration to
disguised data.
\begin{enumerate}[nosep]
    \item[(1)] \sys disguises some user data.
    \item[(2)] The application invokes \sys when it
performs the schema migration; \sys records these the migration update in its replay log.
    \item[(3)] When revealing data, \sys applies the schema migration update to
        diff record data, which maps an original \texttt{users} data row to both
    a row in \texttt{users} with username \texttt{uid} and a row in
\texttt{addrs} that has a foreign key of \texttt{uid} to \texttt{users}
%
The update also generates two rows for any placeholder \texttt{users}
data row in a diff record.
%
\item[(4)] \sys then respectively restores and removes the migrated original data and placeholder
        data respectively, both of which now consist of one \texttt{users} and
        one \texttt{addrs} row.
\end{enumerate}


\subsection{Consistency Checks for Internal Invariants} 
After applying any developer-specified migrations or updates since the time of
disguising, \sys still needs to perform consistency checks on the data to reveal
to ensure that revealing will not violate the database's integrity.
%
These checks only allow revealing if the revealed data: \one{} will still
satisfy uniqueness and primary key constraints; \two{} will not overwrite
modifications that occurred while data was \xxed; and \three{} will maintain
referential integrity.

For \one{}, \sys checks that \emph{removed} \xxed data is still removed from the
database.
%

%
For \two{}, \sys ensures that \emph{modified} \xxed data is in the same modified
state and \emph{decorrelated} \xxed data is still affiliated with the same
pseudoprincipal in the database using the new value stored in the diff record.
%
By default, \sys performs checks at column-granularity. For example, an application
database row can have two modified columns, but at the time of reveal, \sys
finds that only one column still is at the modified state that \sys expects. The
other column must have been updated since the time of the disguise.  \sys will
then only reveal the one matching column that passed the check in order to avoid
overwriting application updates, thus partially restoring the modified row.
Developers can optionally specify that rows must be completely revealed, \ie if
any column fails the check, \sys should not reveal \emph{any} column in the row.
%

%
To ensure \three{}, \sys checks for the existence of all objects referenced by
the data to reveal (\eg a post referenced by a to-be-revealed comment).
%and ensures that any foreign key references to pseudoprincipals to be deleted
%are rewritten to the original.

\sys is conservative and will never reveal rows for which checks fail; the
affected data remains \xxed.  For example, if a developer chooses not to
register conflicting application updates or schema migrations, \sys's checks may
fail, preventing disguised data from being revealed.
%
\sys could flag encountered conflicts, giving the application a chance to fix
them so a later reveal can pass the checks.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Shared Data}
\label{s:shared}


\begin{figure}
    \centering
    \includegraphics[width=.4\textwidth]{figs/shared_hl}
  \caption{\sys supports joint ownership semantics, where shared data is not
    removed until all users have disguised their accounts. Owners can return in
    any order, and the message remains decorrelated from unrevealed owners.}
\label{f:shared:hl}
\end{figure}


%
Many applications support shared data; in Lobsters, for example, messages
between users are owned by both users.
%or co-authored papers in HotCRP.
%
\sys's default semantics for shared data implement an ownership model inspired
by a common treatment of messages as jointly owned.
%
When a user \xxs shared data, \sys decorrelates the data from the \xxing user,
but preserves the data and its association with other owners.
%
\sys removes the data once all users have \xxed it and all ownership links are
to pseudoprincipals.
%
Any owner can reveal the message, which restores the message to the database if
it does not exist, and recorrelates only the revealing user; all disguised
owners remain decorrelated as pseudoprincipals until they also choose to reveal the message.
%
Regardless of the reveal order, if all owners reveal the message, \sys returns
the message to its original state.

%
For instance, consider the scenario in Figure~\ref{f:shared:hl} where Bea and
Chris share a Lobsters message:
\begin{enumerate}[nosep]
    \item[(1)] When Bea \xxs the message, the message is owned by
Chris and a pseudoprincipal;
    \item[(2)] If Chris then \xxs the message, \sys removes it.
    \item[(3)] If Bea reveals the message, this restores the message to the database
and recorrelates only Bea; Chris remains decorrelated as a pseudoprincipal.
\item[(4)] When Chris reveals the message, \sys returns
the message to its original state.
\end{enumerate}
%

%
\paragraph{\sys's Solution.}

\begin{figure}
    \centering
    \includegraphics[width=\textwidth]{figs/shared_data}
  \caption{\sys implements joint ownership semantics by storing a fully
    decorrelated REMOVE diff for the shared data (modifications to the shared
    message data are depicted using 
    [owner$\to$pseudoprincipal] notation). Owners can only see
    pseudoprincipals for the other owners in their disguised data. This allows
    \sys to disguise and reveal in any order.}
\label{f:shared:data}
\end{figure}

\sys supports these joint ownership semantics with the following design,
depicted in Figure~\ref{f:shared:data}.
%
\begin{enumerate}
    \item[(1)] The first time any owner removes the data, \sys generates pseudoprincipals for
each owner of the data, and creates a fully-decorrelated version of the shared
data row. 

This decorrelated row is stored as a (plaintext) remove diff record in a
\emph{partially-removed} table created by \sys, indexed by the row's unique
identifier columns (\eg a primary key id).

\item[(2)]
When another owner's disguise removes the data, \sys stores a copy of the
fully-decorrelated diff record for the disguise, diff records recording the
associated pseudoprincipal row and foreign key rewrite for the owner, and a
speaks-for record recording which pseudoprincipal the owner can speaks-for.
%

%
As shown in this example, if the owner also happens to be the last remaining
        owner (all other owners are pseudoprincipals, \ie all other owners have
        removed the data), \sys removes the shared data row from the application
        database, and the fully-decorrelated diff record from \sys's
        partially-removed table.
%

\item[(3)]
When \emph{any} owner chooses to return, \sys first restores the
fully-decorrelated row from the copy of the fully-decorrelated diff record in
the owners's disguised data.  \sys then rewrites the foreign key for the
pseudoprincipal who currently owns the shared data to recorrelate with the
owner, and removes that pseudoprincipal, revealing the other diff records like
normal.
%

\item[(4)] If a subsequent owner reveals the shared data, \sys's consistency checks will
prevent the reveal of the fully-decorrelated row (inserting the row will cause a
duplicate row in the table). However, \sys will still rewrite the foreign key
for that owner's pseudoprincipal to the original owner, and remove the
pseudoprincipal from the database.
%


\end{enumerate}

%



%
Thus, \sys can disguise and reveal shared data no matter the order in which its
owners decide to remove or reveal it. If an owner never removes the shared data,
they will continue to be correlated and have access to the data even if other
owners remove it (and become pseudoprincipals); similarly, if an owner never
restores the shared data, the data will remain forever owned by the owner's
pseudoprincipal if other owners choose to restore it.
%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\input{04-design-composition}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Authenticating As Pseudoprincipals}

As described so far, if Bea wanted to modify a decorrelated ``Star Wars''
comment, they would have to reveal the comment, edit it using their normal
credentials, and then re\xx the comment.
%
\sys applications can also let users modify decorrelated records without the
reveal step.
%
To support this, an application accepts reveal credentials along with a
modification request. \sys uses these credentials to validate that the user
speaks-for a specific pseudoprincipal by walking the speaks-for chain (cf.\
Figure~\ref{f:revealpseudo}) and ensuring that the user can access a speaks-for
record linked to the pseudoprincipal. After validating the user's request, \sys updates
the database with the modification.
%
%previous diff records to reflect the newly modified state.
%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Design Limitations}
\label{s:design:limits}

\paragraph{Disguises.}
\sys assumes that all desired disguises are captured with the three primitive
operations (remove, modify, and decorrelate).
%
Furthermore, disguising transformations may affect data processing of
application data (\eg aggregates over the number of users), or application side
effects dependent on application data (\eg sending notifications).  \sys
currently expects the developer to correctly handle these scenarios, and ensure
that any modified aggregations or placeholder data does not violate application
correctness.
%

\paragraph{API.}
\sys's API assumes that:
\begin{enumerate}[nosep]
    \item the application uses a relational database;
    \item rows to \xx have direct foreign key relationships to a users table,
    where each user corresponds to a row of that table;
    \item all rows to \xx are owned by one or more principals; and
    \item all rows can be uniquely identified (\eg via primary key).
\end{enumerate}
%
Applications that do not satisfy these assumptions---\eg because they have
complex ownership chains or use a NoSQL database---could be supported with
extensions to \sys's design. \sys could use techniques from DELF~\cite{delf} to
support multiple data models; 
%by requiring
%developers to provide \one{} a model of data as objects with dependency edges to other objects,
%and \two{} instantiations for update/delete/insert operations on these objects.
%
and K9DB's data ownership graph~\cite{k9db} to handle indirect data ownership
%, \sys can use an approach similar to
%K9DB's data ownership graph~\cite{k9db}. And 
If no user owns a data item, \sys should likely perhaps refuse to disguise it, and flag
the developer to review the disguise specification.  
%
Finally, to address the unique identification requirement, \sys could add unique
IDs for every data object, so \sys can refind the object when revealing.
However, this method requires more invasive changes to application data. 
%

\paragraph{\sys's Replay Log.}
\label{s:design:updates:limitations}
%\sys's replay log also faces some limitations.
%
%First, developers must do additional work to add hooks to invoke \sys when any
%major application change or schema migration occurs. 
%%
%Invoking these hooks and applying these updates during reveal also adds
%additional computation work; we measure these costs in \S\ref{s:eval:updates}.
%

%
Updates in replay logs only apply to diff records, which contain the actual
data changes, and not speaks-for records; \sys assumes that the identifiers for
principals in speaks-for records that encode the speaks-for chain remain
consistent as the database changes, allowing \sys to use its composition
techniques with speaks-for chains (\S\ref{s:design:oooreveals}) to reveal
multiple disguises in any order.
%

%
Furthermore, as described in \S\ref{s:overview:updates}, \sys assumes that
either \one{} updates are pure functions deterministic in their input and do not
have side effects; or \two{} any nondeterministim or update side effects will
maintain application correctness.
%
One potential solution would be for developers to indicate the data dependencies
of each update, so \sys could know to \eg restore votes before posts in the
vote count example from \S\ref{s:overview:updates}. However, this
requires \sys to disable foreign key checks and carefully check for referential
integrity after restoring posts, since restoring votes first can now
inadvertently leave dangling pointers. 
%
A perhaps more realistic but more limited solution might require developers to
schedule cron jobs to habitually perform the update to ``fix up'' any rows that
have been revealed since the update. However, this only works for an idempotent
update, as it should not incorrectly update already-updated rows again.  
%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Security Discussion}
\label{s:eval-security}

%
%We now analyze what security \sys's design provides.
%
\sys's design achieves confidentiality of disguised data between the time of
disguising and revealing, its key goal.
%
Some aspects of \sys's design help make \sys practical and deployable without
major application modifications, but give up stronger security in exchange for
usability.
%

%Because \sys encrypts \xxed data, \sys achieves:
%lyt: I didn't like this because we already talk about encrypting disguised data
%below, and this is only a subset of WHY Edna achieves these security guarantees
%
Under \sys's threat model, \sys achieves:
\begin{enumerate}[nosep]
    \item confidentiality of disguised data, via encrypting disguised data using asymmetric encryption, so only the owning user’s private key can reveal it;
    \item confidentiality of which encrypted disguised data belongs to which
        user, via opaque, encrypted indexing to reference a user’s disguised data; and
    \item reduced linkability between parts of a user's data, via splitting data ownership among pseudoprincipals.
\end{enumerate}
%
However, an attacker sees all application database
content and code, and \sys's \xx, principal, and deleted principal tables.
%
Thus, what the attacker learns includes:
\begin{enumerate}[nosep]
  \item any un\xxed data in the application database;
  \item the active principals that have \xxed data, via \sys's principal
      table;
  \item the pseudoprincipals currently registered, from \sys's
    principal table and the application DB;
  \item the number of deleted principals, via the size of the deleted
    principal table;
  \item the amount of \xxed data in \sys; and
  \item the \xx specifications, from application code.
\end{enumerate}

%
\sys provides decorrelation with pseudoprincipals to ease integration with
existing applications, even though pseudoprincipals (and their mere existence) can
reveal information to the attacker.
%
Pseudoprincipals preserve application data and referential integrity, ensuring that
\eg every post always has an author, or that vote counts on posts remain unchanged,
without requiring the developer to handle special cases of deleted users and
orphaned data.
%
However, this necessarily leaves information in the database.
% that an attacker could use.
%

Similarly, leveraging the application database to store \xxed data increases \sys's
practicality as it reuses existing server-side storage and avoids burdening
users with managing their disguised data, but leaves potentially
exploitable metadata available to attackers.
%
An attacker could leverage pseudoprincipal groupings (\eg a pseudoprincipal
owning posts in both ``CMU 2018'' and ``BayArea'' topics), un\xxed data
(\eg comments signed with the user's name), and \sys metadata (\eg that some
anonymous user has more \xxed data than another, as \sys stores \xxed data without
padding for efficiency) to infer the identity of the original owning principal.

Finally, \sys makes no guarantees for users who actively use \xxed data after
compromise (\eg by revealing or editing decorrelated data): after an attacker
compromises the application at time $t$, they can harvest private keys that
clients provide after $t$.
%
However, \sys always protects users' \xxed data if they remain inactive.
%
%%Likewise, when a client provides $(\lcapa{pd}, p, d)$ to operate over data under
%%disguise, the attacker learns the correspondence between \lcapa{pd} and $(p, d)$.
%
%%But this merely makes the attack more efficient, as the attacker can already discover
%%$p$'s disguise history by attempting to decrypt all bags with $p$'s private key.
%
%However, the attacker cannot gain access to any previously-revealed data that users
%subsequently removed from the application database.
%

%
%: viable protections (\eg storing
%\xxed data externally, \xxing all user data, or padding \xx records and
%pseudoprincipal counts) can break application functionality by removing too much
%data, prevent further \xxing of pseudoprincipal-owned data, and result in
%prohibitively expensive space costs.
%

%
%The attacker could also try to leverage remaining data in the application
%database, the size of the \xxed data, and the number of registered
%pseudoprincipals for a statistical inference attack that lets them conclude
%which pseudoprincipals likely correspond to a natural principal.
%%
%\sys does not protect against such attacks: viable protections would break the
%application for others by removing too much data from the application DB and
%require expensive padding of \xxed data and the pseudoprincipal count.
%%

%as the cost of the necessary protections would be
%prohibitive: \sys would have to add padding to every bag and pseudoprincipal locator set, and the
%amount of padding would need to be proportional to the largest amount of data any natural principal
%holds in the application DB (see \S\ref{s:disc}).
%
%However, \sys guarantees that the attacker cannot tell the \emph{identity} of an inactive natural
%principal correlated with some pseudoprincipal(s) based on the compromised information, since the
%natural principal has been removed from the application DB and from \sys's metadata.


%We note that our threat model puts privilege-escalation and root privilege attacks out of scope:
%thus, an adversary cannot observe privilege-protected query logs or other database metadata that
%would potentially leak \xxed data~\cite{grubbs}. While \sys provides no guarantees for
%root-privilege attacks, \sys increases the difficulty of extracting \xxed data. \lyt{Move
%this last paragraph somewhere?}

%\textbf{Security of Reveal Credentials.}
%
%
The attacker never has access to a user's private key unless the user actively
provides their credentials.
%
The attacker also cannot access the private key of any pseudoprincipal because
it is in an encrypted speaks-for record.
%
% By induction, the attacker cannot access any private keys.
%
If an application uses password-based reveal credentials, \sys
guarantees security equivalent to the security of the user's password.


