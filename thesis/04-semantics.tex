This chapter describes \sys's high-level semantics that a developer can use to
reason about the resulting state of data after a disguise and reveal, and 
includes an overview of \sys's API.

\section{Disguising and Revealing}
\label{s:semantics:hl}
Developers can think about disguising transformations as removing and rewriting
data in the application database.
%
The database starts at some original application state, and alters application
data depending on the disguise specification (\S\ref{s:semantics:spec}).  The resulting
state---the disguised data state---is changed only by another disguise, by
revealing the applied disguise, or by normal application updates.
%

%
Disguising already-disguised data can only decrease the amount of information
retained about the original application data state. Removed data cannot be
disguised again. If the original data has been rewritten by prior disguises,
future disguises of the disguised state have access only to the disguised state,
and thus can only further remove aspects of the original data state.
%

Disguises may insert pseudoprincipals (anonymous users) into the application
database if the disguise's specification includes a decorrelation---a rewriting
of a foreign key to point to an anonymous pseudoprincipal instead of the
original principal user. Data disguised within the same disguise and from the
same table may refer to (via a foreign key) the same pseudoprincipal.
%
No two objects from different database tables refer to the same pseudoprincipal,
and no two disguises' sets of produced pseudoprincipals overlap.

%
\sys applies disguises on behalf of either a single user or all users. However,
only a user can reveal a disguise on their data, and must provide a reveal
credential to \texttt{RevealData}.
%

%
Revealing a disguise $D$ on some data disguised by $D$ reverts the changes to
the data applied by $D$ back to the pre-disguised state, except in two cases.
First, if a normal application update has since changed the disguised data, then
the data remains in its updated state and cannot be revealed.
%
Second, if another disguise has since applied changes to the data $D$ disguised,
and that disguise has not yet been revealed, then the data remains in its
current state.
%
Only when all subsequent disguises are revealed does the data revert to the
state prior to $D$.
%
Thus, when multiple disguises apply to the same data, the application data state
reflects the effects of all yet-unrevealed disguises.
%

Revealed data will also reflect all global database updates (such as schema
migrations) registered by the developer since the time of disguise, applied in
chronological order.


\paragraph{\sys without encryption.}
\label{s:semantics:noencrypt}

Developers may find \sys's threat model unnecessarily strong: perhaps they do
not worry about data breaches, care about regulations like the GDPR, or trust
their application code to not expose disguised data. Instead, these developers
may want to add disuising and revealing without encryption.
%
\S\ref{s:noencrypt-api} describes how removing encryption would change \sys's
API, and \S\ref{s:noencrypt} describes how it would change
\sys's design.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{API}
\label{s:api}

\begin{figure}[t]
\begin{lstlisting}[style=rust,escapeinside={(*}{*)}]
// Generates keypair for p and returns the user's backup credential
(*\textbf{RegisterPrincipal}*)(
        u: UID, 
        pw: Password,
        pubkey: PublicKey, 
        privkey: PrivKey)
    -> RevealCredential;

// disguises principal p according to the spec, 
// optionally over already-disguised data ((*\S\ref{s:composition}*))
(*\textbf{DisguiseData}*)(
        uopt: Option<UID>, 
        spec: DisguiseSpec,
        principal_gen: PrincipalGenerator,
        schema: Schema,
        disguise_over: Option<RevealCredential>) 
    -> disguiseID;

// Reveals data disguised by s for u with u's username password. 
(*\textbf{RevealData}*)(
        u: UID, 
        cred: RevealCredential,
        did: disguiseID, 
        pp_ref_policy: PseudoprincipalReferencePolicy,
        allow_partial_row_reveal: bool,
        schema: Schema)
    -> bool;

// Gets principals that u can speak-for.
(*\textbf{CanSpeakFor}*)(u: UID, cred: RevealCredential) -> Vec<UID>;

// Records a reveal-time update spec in the replay log.
(*\textbf{RecordUpdate}*)(update_spec: RevealTimeUpdateSpec) -> bool;
\end{lstlisting}
\caption{\sys's API (Rust-like syntax).}
\label{f:api-high}
\end{figure}
%

Developers add disguising and revealing to their application via \sys's API,
which consists of the functions shown in Figure~\ref{f:api-high}. This section
describes each function and how developers would use them to support disguising
and revealing.

\subsection{\texttt{RegisterPrincipal}}
    Registers an application user as a principal whose data can be disguised and
    revealed. Unique users should not be registered multiple times. Once
    registered, data of an undeleted user that exists in the database can always
    be disguised and revealed.  Users deleted by a disguise do not need to
    reregister if revealed.

    Returns a backup token that the application should return to
    the user client as a backup reveal credential.

    \begin{center}
    \begin{longtable}{|m{0.13\textwidth}|m{0.8\textwidth}|}
        \hline
        \textbf{Argument} & \textbf{Description} \\
        \hline
        \texttt{u} & the user's unique identifier.\\
        \hline
        \texttt{pw} & the user's password (later usable as a reveal credential).\\
        \hline
        \texttt{pubkey} & the user's unique public key (used to encrypt the
        user's disguised data).\\
        \hline
        \texttt{privkey} & the user's unique private key (later usable as a reveal
        credential).\\
        \hline
    \end{longtable}
    \end{center}

\subsection{\texttt{DisguiseData}}
    Removes or rewrites application data according to
    the provided disguise specification \texttt{spec}. The original data
    is encrypted and stored within the application database; a user must provide
    credentials to a \texttt{RevealData} call in order to restore the data.

    Returns a unique disguise ID for the applied disguise, which should be
    forwarded to disguised users in case they wish to later reveal the
    disguise.

    \begin{center}
    \begin{longtable}{|m{0.18\textwidth}|m{0.75\textwidth}|}
        \hline
        \textbf{Argument} & \textbf{Description} \\
        \hline
        \texttt{uopt}& (Optional) the disguising user's unique identifier. If
            \texttt{uopt} is \texttt{Some(uid)}, then only data to disguise with
            a foreign key to \texttt{uid} is disguised.\\

        \hline
        \texttt{spec}& the disguise specification provided by the
            developer that describes how to disguise data by
    removing, modifying (replacing some or all of its contents with placeholder
    values), or decorrelating, replacing links to users with links to
    pseudoprincipals.\\

        \hline
        \texttt{principal\_gen}& A principal generator provided by the developer
    that describes how to create a pseudoprincipal in the application (global
            across all disguises).\\
    %
        \hline
        \texttt{schema}& A database schema provided by the developer that specifies
    ownership links from data tables to user tables via foreign key
    relationships (global across all disguises).\\

        \hline
        \texttt{disguise\_over}& (Optional) A reveal credential provided by an
        invoking user (their password, private key, or backup token).
    If \texttt{disguise\_over} is \texttt{Some(cred)}, \texttt{upot} must be
    \texttt{Some(uid)}. \texttt{DisguiseData} will use \texttt{cred} and
    \texttt{uid} to disguise data that has already been disguised
    (\S\ref{s:semantics:hl:composition}).\\
        \hline
    \end{longtable}
    \end{center}

    \subsection{\texttt{RevealData}}

    Restores data disguised by the disguise corresponding to the provided ID to
    the database. Revealing the same disguise ID multiple times will do nothing
    after the first reveal. 

    Returns \texttt{true} if \sys reveals all rows disguised by \texttt{did}
successfully, and \texttt{false} otherwise.

\begin{center}
    \begin{longtable}{|m{0.18\textwidth}|m{0.75\textwidth}|}
        \hline
        \textbf{Argument} & \textbf{Description} \\
        \hline
             \texttt{u}& the revealing user's unique identifier. \\
        \hline
        \texttt{spec} & the revealing user's reveal credential (their password, private key, or
    backup token)\\
        \hline
        \texttt{did}& the identifier for the disguise to reveal\\
        \hline
        \texttt{pp\_ref\_policy} & A pseudoprincipal reference policy provided by the developer (\texttt{RECORRELATE}, \texttt{REMOVE},
    or \texttt{RETAIN}) to ensure that reveals of decorrelations preserve
        referential integrity (see below). \\
        \hline
        \texttt{allow\_partial\_} \texttt{row\_reveal}& A developer-provided flag
        specifying whether a row can be partially restored if some attributes at
            the time of reveal differ from the attribute values set when
            disguising the row.\\
        \hline
        \texttt{schema} & A database schema provided by the developer that specifies
    ownership links from data tables to user tables via foreign key
    relationships (global across all disguises).  \\
        \hline
    \end{longtable}
    \end{center}
    \vspace{-12pt}
    %
\begin{figure}
    \centering
    \includegraphics[width=.7\textwidth]{figs/ppreveal_policies}
    \caption[\texttt{RECORRELATE}, \texttt{REMOVE}, and
    \texttt{RETAIN} policies maintain referential integrity for objects added after disguising that refer to
    a pseudoprincipal during reveal.]{After Bea decorrelates a post (red) to a pseudoprincipal,
    AnonFox, Bea or the application may add posts or other objects that
    reference AnonFox (yellow). When Bea reveals and recorrelates to AnonFox, developers
    can choose to \texttt{RECORRELATE}, \texttt{REMOVE}, or \texttt{RETAIN} any
    new content referring to AnonFox.}
\label{f:ppreveal}
\end{figure}
%

\sys requires the developer to specify a \textbf{pseudoprincipal reference
policy} \texttt{pp\_ref\_policy} because pseudoprincipals may acquire new references
from application objects inserted after the time of disguise---for example, a
decorrelated comment might have new responses. To ensure that revealing a
decorrelate operation---which deletes pseudoprincipals---preserves referential
integrity, developers inform \sys how to, during reveal, handle these objects
added after disguising that refer pseudoprincipals of the disguise.%

Developers choose between three options for
pseudoprincipal-referring objects: \one{} change the object's
reference to point to the original principal (\texttt{RECORRELATE});
\two{} delete the object (\texttt{REMOVE}); or \three{} continue
referring to the pseudoprincipal (\texttt{RETAIN}).
Figure~\ref{f:ppreveal} demonstrates the result of each policy when
revealing a post added to Bea's pseudoprincipal after a
decorrelation disguise.

This option applies to all rows to reveal; another choice of API
could support a menu of options, such as per-table checks and fixes
(where the developer specifies per-table policies) or
per-inserted-object ones (where the developer makes application
modifications to log all added references to pseudoprincipals).

\subsection{\texttt{CanSpeakFor}}
    Finds all principals in the application identified by user ID that stem from
    a (potentially recursive) decorrelation of user \texttt{p}, authorizing user \texttt{p}
    to speak-for any of these principals. 

    Returns a list of all user IDs of principals that \texttt{p} can speak-for.

\begin{center}
    \begin{longtable}{|m{0.18\textwidth}|m{0.75\textwidth}|}
        \hline
        \textbf{Argument} & \textbf{Description} \\
        \hline
             \texttt{u}& the user's unique identifier. \\
        \hline
             \texttt{cred}& the user's reveal credential (their password, private key, or
    backup token).\\
        \hline
    \end{longtable}
    \end{center}
   
    
\subsection{\texttt{RecordUpdate}}
\label{s:semantics:updates}

Enables a developer to perform updates to disguised data prior to revealing it.
%Invoking \texttt{RecordUpdate} timestamps and logs a developer-provided update
%specification---a data transformation function---to reflect a global update
%performed on undisguised data. All updates since the time of disguise will be
%performed in chronological order on disguised data prior to revealing it.
If the provided reveal-time update specification relies on data external to the
disguised data to reveal (\eg the current time or state of undisguised data),
\sys cannot ensure correctness when applying the update to disguised data at
reveal time.

Returns \texttt{true} on successful recording in \sys's
    log, and \texttt{false} on failure.

\begin{center}
    \begin{longtable}{|m{0.18\textwidth}|m{0.75\textwidth}|}
        \hline
        \textbf{Argument} & \textbf{Description} \\
        \hline
             \texttt{update\_spec}& a reveal-time update specification reflecting
    the data transformations performed on table rows. The specification maps a
    set of table rows to a set of updated table rows.\\
        \hline
    \end{longtable}
    \end{center}

    
\subsection{\sys's API Without Encryption}
\label{s:noencrypt-api}
A subset of Edna's API suffices to provide the same semantics for disguises
without encryption. Users do not need to register with \sys; applications can
use normal user authentication to authorize revealing; disguising
already-disguised data no longer requires a user's reveal credential; and
reveal-time updates can be applied immediately to disguised data instead of
logged and applied at reveal time.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Disguise Specifications}
\label{s:semantics:spec}

%
A developer describes the effects of a disguise (and undone by a
reveal) via disguise specifications.  As previously shown in
Figure~\ref{f:spec}, each specification operation consists of the disguise
operation type, the database table name, 
and a SQL \fn{WHERE} predicate.

%
A disguise is invoked either automatically by the application, or by a specific
user of the application identified by their user ID. 
% 
If disguise is user-specific, then only data that has a foreign key to that
user's identifier (is ``owned'' by that user) and matches the disguise
specification's predicate will be disguised. Invoking a disguise with
\texttt{uopt = Some(uid)} will thus add a condition on a disjunction of
"\texttt{[fk\_col] = [uid]}" clauses for all foreign keys \texttt{fk\_col} to
the application's principals table. For example, a predicate of \texttt{WHERE
true} to disguise all data of a table will turn into \texttt{WHERE true AND
(author1 = uid OR author2 = uid)}.

If not invoked by a specific user, the disguise applies to
all data matching the disguise specification's predicate.

This section next dives into the semantics of each disguise operation type.
%

\paragraph{Remove.}
A remove operation removes the entire row that matches the operation's
predicate.
%
Developers should take care to handle referential integrity to removed rows, as
\sys will not cascade-delete referencing rows or introduce placeholders.
(Developers should instead use decorrelate operations to remove principal
rows and replace them with pseudoprincipals).
%

%
A reveal of a remove operation will reinsert all removed rows, unless
reinserting the row will violate a primary key or uniqueness constraint of the
application.
%

%
\paragraph{Modify.}
A modify operation works at per-column granularity, and requires developers to
specify a modification policy for each column to modify in addition to the table
name and predicate.
%
The modification policy informs \sys how to generate new placeholder values for
each column to modify using one of \sys's value generation policies. The current
prototype supports constants (\eg "removed"), random values (\eg a random email
address), and values derived from the prior value (\eg a redacted phone number
with only area code visible).
%

%
Revealing a modify operation restores a row's column back to its state prior
to the disguise \emph{only if} the current column value matches the value
generated by the modify operation during the disguise. This prevents a reveal
from overwriting application changes to the column value since the time of
disguise.
%
Some rows may thus end up partially revealed, with only some modified columns
restored back to the original pre-disguise state.  Developrs can set a (global)
flag to disable partial row reveals, to prevent revealing of any column values
in a row with at least one conflicting column value.
%

%
\paragraph{Decorrelate.}
%
A decorrelate operation requires developers to additionally specify \one{} which
foreign keys for the table rows to rewrite, and \two{} a
\texttt{group\_by} attribute if rows with the same value for that attribute
should refer to the same pseudoprincipal after decorrelation.
%
A decorrelate operation only applies to rows with foreign key relationships to
the principals table (if specified on other foreign keys, the operation will do
nothing).
%
Developers also provide a global pseudoprincipal-generation policy
(using \sys's value generation policies) to tell \sys how to generate per-column
placeholder values.
%

%
If a user invokes the disguise, then \sys only decorrelates the specified
foreign key attributes that refer to that user's identifier, and whose
rows match the predicate. 
%
Otherwise, if the disguise applies over all users, then \sys decorrelates all
specified foreign keys for all rows matching the predicate.
%

%
For all rows to decorrelate with the same \texttt{group\_by} attribute value,
\sys rewrites the foreign keys to decorrelate to the same randomly generated
pseudoprincipal.
%
If no \texttt{group\_by} attribute is specified, each row gets a unique
pseudoprincipal.
%
Thus, no two disguises share the same pseudoprincipals, and no two tables share
the same pseudoprincipals.
%

\section{Disguising and Revealing Example}
   
%
\begin{figure}
    \centering
    \begin{subfigure}[t]{.47\columnwidth}
    \centering
    \includegraphics[width=.75\textwidth]{figs/composition-hl-inorder}
  \caption{Bea's reveal of ``Star Wars'' posts keeps ``Ewok'' posts still
        decorrelated under the ``bears'' disguise. Only after revealing
        ``bears'' posts does \sys restore ownership back to Bea.}
    \label{f:composition-hl-inorder}
    \end{subfigure}
    \hfill
\begin{subfigure}[t]{.47\columnwidth}
    \centering
    \includegraphics[width=.75\textwidth]{figs/composition-hl-ooo}
  \caption{Bea's reveal of ``bears'' posts keeps ``Ewok'' posts still
    decorrelated under the ``Star Wars''
    disguise, even though the ``Star Wars'' disguise applied after ``bears''. Only after revealing ``Star Wars'' posts does \sys restore ownership back to
    Bea.}
\label{f:composition-hl-ooo}
\end{subfigure}
    \caption[\sys only reveals the original state of data disguised multiple times once
    all disguises appied to the data have been revealed.]{
        If Bea decorrelates an ``Ewok'' post twice---once via a ``bears''
        disguise, and once via a ``Star Wars'' disguise---\sys only recorrelates
        the post back to Bea once Bea reveals \emph{both} disguises.}
\label{f:composition-hl}
\end{figure}

%
For example, if a post is disguised twice---once to modify the timestamp, and
again to scrub its content---then revealing only one disguise will restore only
that attribute (\eg a timestamp or the post content). 
%
This also applies for disguises that rewrite the same data attributes. For
example, if one disguise decorrelates all ``bears'' posts from their author to
$P_1$ (\ie by rewriting their \texttt{author} foreign key values to the $P_1$
pseudoprincipal) and another disguise decorrelates all ``Star Wars'' posts to
$P_2$, then ``Ewok'' posts will have been twice decorrelated. 
%
This means the post will remain decorrelated to $P_1$ even if the ``Star Wars''
disguise decorrelating to $P_2$ is revealed
(Figure~\ref{f:composition-hl-inorder}).
%
And if only the ``bears'' 'disguise decorrelating to $P_1$ were revealed, but
not the ``bears'' disguise, the data would remain decorrelated to $P_2$ until
the user also reveals the ``Star Wars'' disguise
(Figure~\ref{f:composition-hl-ooo}).
%
%
Revealing transformations also apply a developer's provided reveal-time updates
(\S\ref{s:semantics:updates}) to the data to reveal, ensuring that revealed data
reflects global application updates since the time of disguise.
%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Shared Data}
Many applications support shared data; in Lobsters, for example, messages
between users are owned by both users.
%or co-authored papers in HotCRP.
%
\sys's default semantics for shared data implement an ownership model inspired
by a common treatment of shared data as jointly owned.
%
When a user's disguise removes shared data, \sys decorrelates the data from the
\xxing user, but preserves the data and its association with other owners.
%
\sys removes the data once all users have \xxed it and all ownership links are
to pseudoprincipals.
%
Any owner can reveal the message, which restores the message to the database if
it does not exist, and recorrelates only the revealing user; all disguised
owners remain decorrelated as pseudoprincipals until they also choose to reveal
the message.
%
Regardless of the reveal order, if all owners reveal the message, \sys returns
the message to its original state.
%

%
For each shared data object, each owner has an associated unique
pseudoprincipal. If ony some owners have disguised the row, the row will refer
to the disguised owners' unique pseudoprincipals' identifiers instead of the
owners'.
%
When a user reveals a shared data row, all users still disguised remain
associated with their unique pseudoprincipal (which can be reused over multiple
remove disguises).
%

\begin{figure}
    \centering
    \includegraphics[width=.4\textwidth]{figs/shared_hl}
    \caption[\sys supports joint ownership semantics when disguising shared data.]{\sys supports joint ownership semantics, where shared data is not
    removed until all users have disguised their accounts. Owners can return in
    any order, and the message remains decorrelated from unrevealed owners.}
\label{f:shared:hl}
\end{figure}

%
For instance, consider the scenario in Figure~\ref{f:shared:hl} where Bea and
Chris share a Lobsters message. Bea maps to unique pseudoprincipal AnonPig for this
shared message, and Chris to AnonFox.
\begin{enumerate}[nosep]
    \item[(1)] When Bea \xxs the message, the message is owned by
Chris and a pseudoprincipal;
    \item[(2)] If Chris then \xxs the message, \sys removes it.
    \item[(3)] If Bea reveals the message, this restores the message to the database
and recorrelates only Bea; Chris remains decorrelated as a pseudoprincipal.
\item[(4)] When Chris reveals the message, \sys returns
the message to its original state.
\end{enumerate}
%
\S\ref{s:design:shared} dives deeper in how \sys's design achieves these shared
data semantics.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Disguise Composition}
\label{s:semantics:hl:composition}

Users may also wish to disguise data previously decorrelated from their
account. In this scenario, \sys requires users to reveal their correlations to
pseudoprincipals in order to further disguise their pseudoprincipals' data.
%
If a user wants to further disguise their pseudoprincipal's data, then the user
can grant \sys permission to reveal links to their pseudoprincipal by providing
a reveal credential (their password, private key, or backup token). 
%
\sys will then treat all of the user's pseudoprincipals' data as if they belong
to the user themself, and depending on the disguise specification, will remove,
modify, or create a new pseudoprincipal owner for these pseudoprincipals' data.
%
To reveal their data back to its original state, a user must reveal all
disguises composed atop the data.
%
\S\ref{s:composition} fleshes out \sys's design for disguise composition.

